<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Legendary Umbrella — Marine Weather & Nav</title>
<link rel="icon" href="favicon.ico">
<meta name="theme-color" content="#0a0f15">

<!-- Leaflet (sync load) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  /* Improve button active state with clear highlight */
.btn.active {
  background-color: var(--accent);
  color: #fff;
  border-color: var(--accent);
}
button:disabled {
  opacity: 0.6;
  cursor: wait;
}
/* Tooltip improvement */
.leaflet-tooltip.my-tooltip {
  background: var(--card);
  color: var(--ink);
  font-weight: 600;
  padding: 5px 8px;
  border-radius: 4px;
  box-shadow: 0 0 10px rgba(0,0,0,0.3);
}

  :root{
    --bg:#0a0f15; --panel:#0f1620; --card:#111a27; --line:#1b2a3b;
    --ink:#e9f0f8; --muted:#9fb2c8; --accent:#22c55e; --warn:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
  header{padding:14px 16px;border-bottom:1px solid var(--line);display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  header h1{font-size:18px;margin:0}
  .brand{padding:4px 10px;border:1px solid var(--line);border-radius:999px;background:#0d1a26}
  .status{margin-left:auto;font-size:12px;color:var(--muted)}
  main{display:grid;grid-template-columns:1fr;gap:12px;padding:12px;max-width:1100px;margin:0 auto}
  @media(min-width:1000px){ main{grid-template-columns:1fr 380px;} }
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:12px}
  #map{height:60vh;min-height:420px;border-radius:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button,.btn{cursor:pointer;border:1px solid var(--line);background:#111a27;color:var(--ink);border-radius:10px;padding:8px 12px}
  input{background:#0e1320;border:1px solid var(--line);color:var(--ink);border-radius:10px;padding:8px 10px;min-width:220px}
  pre{white-space:pre-wrap;max-height:42vh;overflow:auto;background:#0b121c;border-radius:10px;padding:10px;border:1px solid var(--line)}
  .error{background:#2a0f0f;border-color:#5a1d1d}
  .good{color:var(--accent)}
  .metric{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;font-size:14px}
  .metric b{color:var(--ink)}
  .muted{color:var(--muted)}
  .btn.active{ outline:2px solid var(--accent); }
  .chip{display:inline-block;border:1px solid var(--line);border-radius:999px;padding:2px 8px;margin-right:6px;background:#0e1724}
  .veh{ filter: drop-shadow(0 0 2px rgba(0,0,0,.6)); }

  /* Speedometer */
  .speedo{display:grid;place-items:center;padding:16px}
  .gauge{width:220px;height:110px;background:conic-gradient(#1f2b3a 0 180deg);
    border-bottom-left-radius:220px;border-bottom-right-radius:220px;position:relative;border:1px solid var(--line)}
  .needle{position:absolute;left:50%;bottom:0;transform-origin:bottom center;width:2px;height:100px;background:#eaeaea;box-shadow:0 0 6px rgba(255,255,255,.6)}
  .ticks{position:absolute;left:0;top:0;width:100%;height:100%}
  .speed-read{margin-top:8px;font-size:28px;font-weight:700;text-align:center}
  .units{font-size:12px;color:var(--muted);text-align:center;margin-top:-6px}
</style>
</head>
<body>
<header>
  <div class="brand">Ceol Gan Eagla</div>
  <h1>Legendary Umbrella — Marine Weather & Nav</h1>
  <div class="status" id="status">Booting…</div>
</header>

<main>
  <!-- LEFT: Map + Controls -->
  <section>
    <div class="card">
      <div class="row" style="margin-bottom:8px">
        <button id="btnTrack">Start tracking</button>
        <button id="btnCenter">Center on me</button>
        <button id="btnFull">Fullscreen map</button>
        <span class="muted">Layers: </span>
        <button id="btnOSM" class="btn">OSM</button>
        <button id="btnOcean" class="btn">Ocean</button>
        <button id="btnSat" class="btn">Satellite</button>
        <button id="btnSeamark" class="btn">Seamarks</button>
        <button id="btnDepth" class="btn">Depth</button>
        <button id="btnRivers" class="btn">Rivers</button>
        <button id="btnHarbours" class="btn">Harbours</button>
        <button id="btnFuel" class="btn">Fuel</button>
        <button id="btnPiers" class="btn">Piers</button>
        <button id="btnAircraft" class="btn">Aircraft</button>
        <button id="btnBoats" class="btn">Boats</button>
      </div>
      <div id="map"></div>
      <div class="muted" style="margin-top:6px">
        Basemaps: <span class="chip">OpenStreetMap</span> <span class="chip">Esri World Ocean</span>
        <span class="chip">Esri Imagery (Satellite)</span> & overlays
        <span class="chip">OpenSeaMap Seamarks</span> <span class="chip">Depth</span> <span class="chip">Rivers</span>
        <span class="chip">Harbours</span> <span class="chip">Fuel</span> <span class="chip">Piers</span>.
      </div>
    </div>

    <div class="card" id="wxCard" style="margin-top:12px">
      <div class="row" style="margin-bottom:6px">
        <button id="btnGeo">Use my location</button>
        <input id="city" placeholder="Enter city (e.g., Dublin)" />
        <button id="btnCity">Get weather</button>
        <span class="muted">API base: <b id="apiBaseTxt">—</b></span>
      </div>
      <div class="metric" id="wx">
        <div class="muted">Temp:</div><b id="mTemp">—</b>
        <div class="muted">Wind:</div><b id="mWind">—</b>
        <div class="muted">Gust:</div><b id="mGust">—</b>
        <div class="muted">Direction:</div><b id="mDir">—</b>
        <div class="muted">Precip Prob:</div><b id="mPop">—</b>
        <div class="muted">Cloud Cover:</div><b id="mCloud">—</b>
      </div>
      <pre id="raw" style="display:none"></pre>
      <div id="err" class="card error" style="display:none;margin-top:8px"></div>
    </div>
  </section>

  <!-- RIGHT: Speedometer + Info -->
  <aside class="rightcol">
    <div class="card speedo">
      <div class="gauge" id="gauge">
        <div class="needle" id="needle" style="transform:translateX(-50%) rotate(180deg)"></div>
        <svg class="ticks" viewBox="0 0 100 50" preserveAspectRatio="none">
          <g stroke="#334a63" stroke-width="0.6">
            <line x1="5" y1="48" x2="5" y2="44"/>
            <line x1="15" y1="48" x2="15" y2="44"/>
            <line x1="25" y1="48" x2="25" y2="44"/>
            <line x1="35" y1="48" x2="35" y2="44"/>
            <line x1="45" y1="48" x2="45" y2="44"/>
            <line x1="55" y1="48" x2="55" y2="44"/>
            <line x1="65" y1="48" x2="65" y2="44"/>
            <line x1="75" y1="48" x2="75" y2="44"/>
            <line x1="85" y1="48" x2="85" y2="44"/>
            <line x1="95" y1="48" x2="95" y2="44"/>
          </g>
        </svg>
      </div>
      <div class="speed-read" id="spd">0.0</div>
      <div class="units">knots (kn)</div>
      <div class="muted" style="text-align:center;margin-top:6px">Uses GPS speed; falls back to distance over time if speed is missing.</div>
    </div>

    <div class="card">
      <div class="muted">Position</div>
      <div class="metric">
        <div class="muted">Lat:</div><b id="pLat">—</b>
        <div class="muted">Lon:</div><b id="pLon">—</b>
        <div class="muted">Acc:</div><b id="pAcc">—</b>
        <div class="muted">Bearing:</div><b id="pBrg">—</b>
      </div>
    </div>
  </aside>
</main>

<script>
/* ===== Mini rotated-marker helper (inline) ===== */
(function(){
  const proto=L.Marker.prototype, _setPos=proto._setPos;
  proto._setPos=function(pos){
    _setPos.call(this,pos);
    if(!this.options.rotationAngle) return;
    this._icon.style.transformOrigin=this.options.rotationOrigin||"center";
    const a=this.options.rotationAngle;
    const t=(this._icon.style.transform||'').replace(/ ?rotate\\(.*\\)/,'');
    this._icon.style.transform=t+' rotate('+a+'deg)';
  };
  proto.setRotationAngle=function(a){this.options.rotationAngle=a; this.update();};
})();

/*** ====== HOSTING / API BASE ====== ***/
const ON_VERCEL = location.hostname.endsWith('.vercel.app');
const ON_LOCAL = ['localhost','127.0.0.1'].includes(location.hostname);
const VERCEL_ORIGIN = 'https://legendary-umbrella-ashen.vercel.app';
const API_BASE = (ON_VERCEL || ON_LOCAL) ? '' : VERCEL_ORIGIN;
document.getElementById('apiBaseTxt').textContent = API_BASE || '(same-origin)';

const $ = (id)=>document.getElementById(id);
const setStatus = (t)=>{$('status').textContent=t;}
const showErr = (msg)=>{ const e=$('err'); e.style.display='block'; e.textContent=msg; }
const clearErr = ()=>{ const e=$('err'); e.style.display='none'; e.textContent=''; }
// Utility debounce helper to prevent rapid firing (e.g., weather fetch)
const debounce = (fn, delay) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), delay);
  };
};

// Enhanced toggle with loading disable state
async function toggleLayer(layerFunc, buttonId) {
  const btn = document.getElementById(buttonId);
  if (!btn || btn.disabled) return;
  btn.disabled = true;
  try {
    await layerFunc(); // your existing toggleAircraft / toggleBoats
    btn.classList.toggle('active');
  } catch(e) {
    showErr(`Error loading ${buttonId}: ${e.message}`);
  } finally {
    btn.disabled = false;
  }
}

// Accessibility: add aria-labels to all buttons
document.querySelectorAll('button').forEach(btn => {
  if (!btn.hasAttribute('aria-label') && btn.textContent.trim()) {
    btn.setAttribute('aria-label', btn.textContent.trim());
  }
});

/*** ====== WEATHER HELPERS ====== ***/
async function getTioKey(){
  const url = `${API_BASE}/api/tio-key`;
  const r = await fetch(url, {cache:'no-store'});
  if(!r.ok) throw new Error(`Failed to reach ${url} → ${r.status}`);
  const j = await r.json();
  if(!j || !j.key) throw new Error('tio-key endpoint returned no key.');
  return j.key;
}
async function tmrForecastByLatLon(lat,lon,key){
  const url = `https://api.tomorrow.io/v4/weather/forecast?location=${lat},${lon}&timesteps=1h&units=metric&apikey=${encodeURIComponent(key)}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error(`Tomorrow.io error: ${r.status} ${r.statusText}`);
  return r.json();
}
async function tmrGeocodeCity(name,key){
  const url = `https://api.tomorrow.io/v4/locations?search=${encodeURIComponent(name)}&apikey=${encodeURIComponent(key)}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error(`Geocode error: ${r.status} ${r.statusText}`);
  const j = await r.json();
  const loc = j?.locations?.[0];
  if(!loc) throw new Error('City not found.');
  return { lat:loc.lat, lon:loc.lon, resolved:`${loc.name}, ${loc.countryCode}` };
}
function setWX(data){
  const point = data?.timelines?.hourly?.[0];
  if(!point){ $('raw').style.display='block'; $('raw').textContent = JSON.stringify(data,null,2); return; }
  const v = point.values || {};
  $('mTemp').textContent = (v.temperature ?? '—') + ' °C';
  $('mWind').textContent = (v.windSpeed ?? '—') + ' m/s';
  $('mGust').textContent = (v.windGust ?? '—') + ' m/s';
  $('mDir').textContent = (v.windDirection ?? '—') + '°';
  $('mPop').textContent = (v.precipitationProbability ?? '—') + ' %';
  $('mCloud').textContent = (v.cloudCover ?? '—') + ' %';
}

/*** ====== MAP & LAYERS ====== ***/
let map, meMarker, meAccuracy, trackId=null, lastFix=null;
let osm, ocean, sat, seamark, depthTiles, riversLayer, harboursLayer, fuelLayer, piersLayer;
riversLayer = L.layerGroup(); harboursLayer=L.layerGroup(); fuelLayer=L.layerGroup(); piersLayer=L.layerGroup();

function initMap(){
  map = L.map('map',{center:[53.35,-6.26],zoom:10,minZoom:2});
  // basemaps
  osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'&copy; OpenStreetMap'}).addTo(map);
  ocean = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}',{ maxZoom:13, attribution:'Esri Ocean'});
  sat = L.tileLayer('https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',{ maxZoom:19, attribution:'Esri Imagery'});

  // overlays
  seamark = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',{ maxZoom:18, opacity:.95, attribution:'OpenSeaMap' });
  depthTiles = L.tileLayer('https://tiles.openseamap.org/depth/{z}/{x}/{y}.png',{ maxZoom:18, opacity:.6, attribution:'OpenSeaMap Depth' });

  // basemap buttons
  $('btnOSM').onclick   = ()=>{ switchBase(osm); };
  $('btnOcean').onclick = ()=>{ switchBase(ocean); };
  $('btnSat').onclick   = ()=>{ switchBase(sat); };
  $('btnSeamark').onclick = ()=>{ toggleOverlay(seamark, $('btnSeamark')); };
  $('btnDepth').onclick   = ()=>{ toggleOverlay(depthTiles, $('btnDepth')); };
  $('btnRivers').onclick  = ()=>{ toggleDataLayer('rivers', $('btnRivers')); };
  $('btnHarbours').onclick= ()=>{ toggleDataLayer('harbours', $('btnHarbours')); };
  $('btnFuel').onclick    = ()=>{ toggleDataLayer('fuel', $('btnFuel')); };
  $('btnPiers').onclick   = ()=>{ toggleDataLayer('piers', $('btnPiers')); };

  $('btnFull').onclick = ()=>{
    const el = $('map'); if(!document.fullscreenElement){ el.requestFullscreen?.(); } else { document.exitFullscreen?.(); }
  };
  $('btnCenter').onclick = ()=>{ if(lastFix){ map.setView([lastFix.coords.latitude,lastFix.coords.longitude], Math.max(map.getZoom(),14)); } };

  setTimeout(()=> map.invalidateSize(), 0);
}
function switchBase(layer){
  [osm,ocean,sat].forEach(l=> map.removeLayer(l));
  layer.addTo(map);
}
function toggleOverlay(layer,btn){
  if(map.hasLayer(layer)){ map.removeLayer(layer); btn.classList.remove('active'); }
  else { layer.addTo(map); btn.classList.add('active'); }
}

/*** ====== GEO / SPEEDO ====== ***/
const R = 6371000;
function toRad(d){ return d*Math.PI/180; }
function haversine(a,b){
  const φ1=toRad(a.lat), φ2=toRad(b.lat), dφ=toRad(b.lat-a.lat), dλ=toRad(b.lon-a.lon);
  const s = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
  return 2*R*Math.asin(Math.sqrt(s));
}
function msToKn(ms){ return Number(ms*1.943844||0).toFixed(1); }
function setNeedle(kn){
  const k = Math.max(0, Math.min(50, parseFloat(kn)||0));
  const deg = 180 - (k/50)*180; // 0→180deg, 50→0deg
  $('needle').style.transform = `translateX(-50%) rotate(${deg}deg)`;
  $('spd').textContent = k.toFixed(1);
}
function updateMeMarker(lat,lon,acc,brg){
  if(!meMarker){
    meMarker = L.marker([lat,lon]).addTo(map);
    meAccuracy = L.circle([lat,lon],{radius:acc||0,color:'#3b82f6',fillColor:'#3b82f6',fillOpacity:0.1}).addTo(map);
  }else{
    meMarker.setLatLng([lat,lon]);
    meAccuracy.setLatLng([lat,lon]).setRadius(acc||0);
  }
  $('pLat').textContent = lat.toFixed(5);
  $('pLon').textContent = lon.toFixed(5);
  $('pAcc').textContent = (acc? acc.toFixed(0)+' m' : '—');
  $('pBrg').textContent = (Number.isFinite(brg)? Math.round(brg)+'°' : '—');
}
function startTracking(){
  if(trackId) return;
  trackId = navigator.geolocation.watchPosition(pos=>{
    lastFix = pos;
    const {latitude:lat, longitude:lon, accuracy:acc, heading, speed} = pos.coords;
    updateMeMarker(lat,lon,acc,heading);
    // speed: prefer native m/s; fallback to distance/time
    let mps = Number.isFinite(speed) && speed!==null ? speed : null;
    if(!mps && window.__prevFix){
      const dt = (pos.timestamp - window.__prevFix.timestamp)/1000;
      if(dt>0){
        const d = haversine({lat:window.__prevFix.coords.latitude,lon:window.__prevFix.coords.longitude},{lat,lon});
        mps = d/dt;
      }
    }
    window.__prevFix = pos;
    setNeedle(msToKn(mps||0));
  }, err=> showErr('GPS error: '+err.message),
  { enableHighAccuracy:true, maximumAge:0, timeout:15000 });
  $('btnTrack').textContent = 'Tracking…';
}
function stopTracking(){
  if(trackId){ navigator.geolocation.clearWatch(trackId); trackId=null; $('btnTrack').textContent='Start tracking'; }
}
$('btnTrack').onclick = ()=> trackId ? stopTracking() : startTracking();

/*** ======= LIVE LAYERS: AIRCRAFT & BOATS ======= */
let aircraftLayer = L.layerGroup();
let boatsLayer = L.layerGroup();
let aircraftTimer = null, boatsTimer = null;

// Icons (plane + boat) rotated by heading/COG
const planeIcon = L.icon({
  iconUrl: "https://cdn-icons-png.flaticon.com/512/3448/3448339.png",
  iconSize: [24, 24],
  iconAnchor: [12, 12]
});
const boatIcon = L.icon({
  iconUrl: "https://cdn-icons-png.flaticon.com/512/77/77521.png",
  iconSize: [24, 24],
  iconAnchor: [12, 12]
});

// AIRCRAFT via OpenSky (proxied by Vercel api/opensky.js)
async function fetchAircraftBBox(){
  const b = map.getBounds();
  const n=b.getNorth(), s=b.getSouth(), e=b.getEast(), w=b.getWest();
  const url = `${API_BASE}/api/opensky?n=${n}&s=${s}&e=${e}&w=${w}`;
  const r = await fetch(url, { cache:'no-store' });
  if(!r.ok) throw new Error('opensky '+r.status);
  return r.json();
}
async function refreshAircraft(){
  try{
    const data = await fetchAircraftBBox();
    aircraftLayer.clearLayers();
    const states = data.states || [];
    for(const s of states){
      const callsign = (s[1]||'').trim();
      const lon = s[5], lat = s[6];
      const gs = s[9];     // m/s
      const track = s[10]; // deg
      const alt = s[13];   // meters (geo/baro)
      if(lat==null || lon==null) continue;

const marker = L.marker([lat, lon], { icon: planeIcon, rotationAngle: track || 0, rotationOrigin: 'center' })
  .bindTooltip(callsign || 'Aircraft', { className:'my-tooltip', direction:'top', offset:[0,-8], sticky:true })
  .bindPopup(
    `<b>✈ ${callsign || 'Unknown'}</b><br>
     Speed: ${gs ? (gs*1.943844).toFixed(1)+' kn' : '—'}<br>
     Track: ${track==null ? '—' : Math.round(track)+'°'}<br>
     Alt: ${alt==null ? '—' : Math.round(alt*3.28084)+' ft'}<br>
     ICAO24: ${s[0]||'—'}`
  );
marker.addTo(aircraftLayer);

    }
  }catch(e){ console.warn(e); }
}
function toggleAircraft(){
  if(map.hasLayer(aircraftLayer)){
    map.removeLayer(aircraftLayer);
    if(aircraftTimer) { clearInterval(aircraftTimer); aircraftTimer=null; }
    $('btnAircraft').classList.remove('active');
  }else{
    aircraftLayer.addTo(map);
    refreshAircraft();
    aircraftTimer = setInterval(refreshAircraft, 10000); // every 10s
    $('btnAircraft').classList.add('active');
  }
}
document.getElementById('btnAircraft').onclick = () => toggleLayer(toggleAircraft, 'btnAircraft');

// BOATS via your AIS proxy (requires AIS_PROXY_URL env var on Vercel)
async function refreshBoats(){
  try{
const title = v.name || v.mmsi || 'Vessel';
const marker = L.marker([v.lat, v.lon], { icon: boatIcon, rotationAngle: v.cog || 0, rotationOrigin:'center' })
  .bindTooltip(title, { className:'my-tooltip', direction:'top', offset:[0,-8], sticky:true })
  .bindPopup(
    `<b>⛵ ${title}</b><br>
     SOG: ${v.sog!=null? Number(v.sog).toFixed(1)+' kn':'—'}<br>
     COG: ${v.cog!=null? Math.round(v.cog)+'°':'—'}<br>
     ${v.mmsi? 'MMSI: '+v.mmsi : ''}`
  );
marker.addTo(boatsLayer);

    });
  }catch(e){ console.warn(e); }
}
function toggleBoats(){
  if(map.hasLayer(boatsLayer)){
    map.removeLayer(boatsLayer);
    if(boatsTimer){ clearInterval(boatsTimer); boatsTimer=null; }
    $('btnBoats').classList.remove('active');
  }else{
    boatsLayer.addTo(map);
    refreshBoats();
    boatsTimer = setInterval(refreshBoats, 15000); // every 15s
    $('btnBoats').classList.add('active');
  }
}
document.getElementById('btnBoats').onclick    = () => toggleLayer(toggleBoats,    'btnBoats');

/*** ====== OSM DATA: Rivers, Harbours, Fuel, Piers (Overpass) ====== */
async function overpass(query){
  const r = await fetch('https://overpass-api.de/api/interpreter', { method:'POST', body: query });
  if(!r.ok) throw new Error('Overpass '+r.status);
  return r.json();
}
function bboxStr(){ const b=map.getBounds(); return `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`; }

async function loadRivers(){
  const bbox=bboxStr();
  const q=`[out:json][timeout:25];
    (way["waterway"~"river|stream|canal"](${bbox}););
    out geom;`;
  const j=await overpass(q);
  riversLayer.clearLayers();
  (j.elements||[]).forEach(w=>{
    if(!w.geometry) return;
    const latlngs=w.geometry.map(p=>[p.lat,p.lon]);
    L.polyline(latlngs,{color:'#62b0ff',weight:2,opacity:.85}).addTo(riversLayer);
  });
}
async function loadHarbours(){
  const bbox=bboxStr();
  const q=`[out:json][timeout:25];
    (node["seamark:type"="harbour"](${bbox}); node["leisure"="marina"](${bbox}););
    out center;`;
  const j=await overpass(q);
  harboursLayer.clearLayers();
  (j.elements||[]).forEach(e=>{
    const lat=e.lat??e.center?.lat, lon=e.lon??e.center?.lon; if(lat==null||lon==null) return;
    L.marker([lat,lon]).bindPopup(`<b>⚓ ${e.tags?.name||'Harbour/Marina'}</b>`).addTo(harboursLayer);
  });
}
async function loadFuel(){
  const bbox=bboxStr();
  const q=`[out:json][timeout:25];
    (node["amenity"="fuel"](${bbox}););
    out center;`;
  const j=await overpass(q);
  fuelLayer.clearLayers();
  (j.elements||[]).forEach(e=>{
    const lat=e.lat??e.center?.lat, lon=e.lon??e.center?.lon; if(lat==null||lon==null) return;
    L.marker([lat,lon]).bindPopup(`<b>⛽ ${e.tags?.name||'Fuel'}</b>`).addTo(fuelLayer);
  });
}
async function loadPiers(){
  const bbox=bboxStr();
  const q=`[out:json][timeout:25];
    (way["man_made"="pier"](${bbox}); relation["man_made"="pier"](${bbox}););
    out center;`;
  const j=await overpass(q);
  piersLayer.clearLayers();
  (j.elements||[]).forEach(e=>{
    const lat=e.lat??e.center?.lat, lon=e.lon??e.center?.lon; if(lat==null||lon==null) return;
    L.marker([lat,lon]).bindPopup(`<b>🛶 ${e.tags?.name||'Pier'}</b>`).addTo(piersLayer);
  });
}

function toggleDataLayer(kind, btn){
  const mapHas=(l)=>map.hasLayer(l);
  const toggle=(layer, loader)=>{
    if(mapHas(layer)){ map.removeLayer(layer); btn.classList.remove('active'); }
    else{ layer.addTo(map); loader().catch(console.warn); btn.classList.add('active'); }
  };
  if(kind==='rivers')   return toggle(riversLayer,  loadRivers);
  if(kind==='harbours') return toggle(harboursLayer,loadHarbours);
  if(kind==='fuel')     return toggle(fuelLayer,    loadFuel);
  if(kind==='piers')    return toggle(piersLayer,   loadPiers);
}

/*** ====== WEATHER CONTROLS / BOOT ====== ***/
async function boot(){
  try{
    clearErr();
    setStatus('Booting…');
    initMap();
    const key = await getTioKey();
    $('status').innerHTML = `API base: <b>${API_BASE || '(same-origin)'}</b> — <span class="good">key ✓</span>`;

    $('btnGeo').onclick = async ()=>{
      try{
        clearErr();
        const pos = await new Promise((res,rej)=>navigator.geolocation.getCurrentPosition(res,rej,{enableHighAccuracy:true, timeout:10000}));
        const {latitude,longitude} = pos.coords;
        const data = await tmrForecastByLatLon(latitude,longitude,key);
        setWX(data);
        map.setView([latitude,longitude], 11);
      }catch(e){ showErr(e.message); }
    };
$('btnCity').onclick = debounce(async () => {
  try {
    clearErr();
    const name = ($('city').value || '').trim();
    if (!name) return showErr('Please enter a city name.');
    setStatus('Fetching city location and weather...');
    // re-use the key we already fetched in boot() if you stored it;
    // if not stored, safely re-call getTioKey():
    const key = await getTioKey();
    const loc = await tmrGeocodeCity(name, key);
    const data = await tmrForecastByLatLon(loc.lat, loc.lon, key);
    setWX(data);
    map.setView([loc.lat, loc.lon], 11);
    setStatus(`Showing weather for ${loc.resolved || name}`);
  } catch (e) {
    showErr(e.message);
    setStatus('Failed to fetch weather.');
  }
}, 500);


// Ensure Leaflet + DOM are ready
document.addEventListener('DOMContentLoaded', () => {
  if (!window.L) {
    window.addEventListener('load', boot, { once: true });
  } else {
    boot();
  }
});
</script>
</body>
</html>
