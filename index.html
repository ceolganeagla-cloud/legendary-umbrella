<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* Show a banner if any JS error bubbles up */
window.onerror = function(msg){ const e=document.getElementById('err'); if(e){e.textContent='Error: '+msg; e.style.display='block';} };

(function(){
  /* ===== CONFIG ===== */
  const MAPTILER_KEY = 'MpDV384cXMNO273WsuTG'; // MapTiler is client-side (lock key to your domain in MapTiler dashboard)

  /* ===== EL ===== */
  const $ = id => document.getElementById(id);
  const el = {
    badge: $('badge'),
    search: $('search'), btnSearch: $('btnSearch'),
    btnGeo: $('btnGeo'), btnPin: $('btnPin'),
    units: $('units'), mapStyle: $('mapStyle'),
    play: $('play'), frame: $('frame'), frametime: $('frametime'),
    opacity: $('opacity'), refresh: $('refresh'),
    nowIcon: $('nowIcon'), temp: $('temp'), wind: $('wind'), precip: $('precip'),
    cloud: $('cloud'), sun: $('sun'), risk: $('risk'), updated: $('updated'),
    hourly: $('hourly'), daily: $('daily'),
    gps: $('gps'), toggleSpeed: $('toggleSpeed'),
    tomorrowWrap: $('tomorrowWrap'), useTomorrow: $('useTomorrow'),
    speedoBtn: $('speedoBtn'), speedHUD: $('speedHUD'),
    closeSpeed: $('closeSpeed'), hudVal: $('hudVal'), hudUnits: $('hudUnits'),
    hudFill: $('hudFill'), hudHead: $('hudHead'), hudMax: $('hudMax'), hudToggle: $('hudToggle'),
    err: $('err')
  };

  /* ===== MAP ===== */
  const map = L.map('map', { zoomControl:true }).setView([53.35,-6.26], 8);
  const styles = {
    streets:   `https://api.maptiler.com/maps/streets-v2/{z}/{x}/{y}.png?key=${MAPTILER_KEY}`,
    outdoor:   `https://api.maptiler.com/maps/outdoor-v2/{z}/{x}/{y}.png?key=${MAPTILER_KEY}`,
    satellite: `https://api.maptiler.com/maps/satellite/{z}/{x}/{y}.jpg?key=${MAPTILER_KEY}`
  };
  let base = L.tileLayer(styles.streets, { attribution: '&copy; OpenStreetMap • &copy; MapTiler' }).addTo(map);
  const markers = L.featureGroup().addTo(map);
  map.createPane('radar'); map.getPane('radar').style.zIndex = 450;
  const radarLayer = L.tileLayer('', { pane:'radar', opacity:0.7 }).addTo(map);

  /* ===== HELPERS ===== */
  let speedUnit='kmh', lastSpeedMs=0, maxSpeed=0, gpsWatchId=null, gotFix=false, radarTimer=null;
  const toF=c=>Math.round(c*9/5+32);
  const msToMph=ms=>Math.round(ms*2.23694);
  const msToKn =ms=>Math.round(ms*1.94384);
  const mmToIn=mm=>Math.round(mm/25.4*100)/100;
  const iconFor=()=> '☁';
  const fmtSpeed = ms=>{
    if(ms==null||isNaN(ms)) ms=0;
    if(speedUnit==='kmh') return Math.round(ms*3.6)+' km/h';
    if(speedUnit==='mph') return Math.round(ms*2.23694)+' mph';
    return Math.round(ms*1.94384)+' knots';
  };
  function updateSpeedUI(heading){
    el.gps.textContent = '⏱ '+fmtSpeed(lastSpeedMs);
    el.toggleSpeed.textContent = 'Units: ' + (speedUnit==='kmh'?'km/h':speedUnit==='mph'?'mph':'knots');
    // HUD
    const val = speedUnit==='kmh'? lastSpeedMs*3.6 : speedUnit==='mph'? lastSpeedMs*2.23694 : lastSpeedMs*1.94384;
    const cap = speedUnit==='kmh'? 60 : speedUnit==='mph'? 40 : 30;
    if (el.hudVal){ el.hudVal.textContent = Math.round(val); }
    if (el.hudUnits){ el.hudUnits.textContent = (speedUnit==='kmh'?'km/h':speedUnit==='mph'?'mph':'knots'); }
    if (el.hudFill){ el.hudFill.style.width = Math.min(100, Math.round(val/cap*100))+'%'; }
  }
  function setMarker(lat,lon,label){
    markers.clearLayers();
    L.marker([lat,lon]).addTo(markers).bindPopup(label||'Here').openPopup();
  }

  /* Map style switch */
  el.mapStyle.addEventListener('change', e=>{
    const v=e.target.value;
    if (base) map.removeLayer(base);
    base = L.tileLayer(styles[v], { attribution: '&copy; OpenStreetMap • &copy; MapTiler' }).addTo(map);
  });

  /* ===== Radar (RainViewer) ===== */
  const RV={frames:[],idx:0};
  function loadRadar(){
    fetch('https://api.rainviewer.com/public/weather-maps.json',{cache:'no-store'})
      .then(r=>r.json()).then(j=>{
        RV.frames=[...(j?.radar?.past||[]), ...(j?.radar?.nowcast||[])];
        el.frame.max=Math.max(RV.frames.length-1,0);
        setRadar(RV.frames.length-1);
      }).catch(()=>{});
  }
  function setRadar(i){
    if(!RV.frames.length) return;
    RV.idx=Math.max(0,Math.min(i,RV.frames.length-1));
    const fr=RV.frames[RV.idx]; if(!fr) return;
    radarLayer.setUrl(`https://tilecache.rainviewer.com/v2/radar/${fr.time}/256/{z}/{x}/{y}/2/1_1.png`);
    el.frametime.textContent=new Date(fr.time*1000).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
  }
  el.frame.addEventListener('input', e=>setRadar(+e.target.value));
  el.play.addEventListener('click', ()=>{
    if (radarTimer){ clearInterval(radarTimer); radarTimer=null; el.play.textContent='▶︎'; return; }
    if (!RV.frames.length) return;
    el.play.textContent='⏸';
    radarTimer=setInterval(()=>{ const n=(RV.idx+1)%RV.frames.length; el.frame.value=n; setRadar(n); },700);
  });
  el.opacity.addEventListener('input', e=>radarLayer.setOpacity(+e.target.value));
  el.refresh.addEventListener('click', loadRadar);

  /* ===== Search / Geo ===== */
  el.btnSearch.addEventListener('click', doSearch);
  el.search.addEventListener('keydown', e=>{ if(e.key==='Enter') doSearch(); });
  function doSearch(){
    const q=el.search.value.trim(); if(!q) return;
    const eir=/^[A-Z0-9]{3}\s?[A-Z0-9]{4}$/i;
    const url = eir.test(q)
      ? `https://nominatim.openstreetmap.org/search?postalcode=${q.replace(/\s+/g,'')}&countrycodes=ie&format=json&addressdetails=1&limit=5`
      : `https://nominatim.openstreetmap.org/search?format=json&limit=5&q=${encodeURIComponent(q)}`;
    fetch(url,{headers:{'Accept-Language':'en'}})
      .then(r=>r.json()).then(arr=>{
        if(!arr||!arr.length) return;
        const lat=parseFloat(arr[0].lat), lon=parseFloat(arr[0].lon), name=arr[0].display_name||'Location';
        map.setView([lat,lon],11); setMarker(lat,lon,name); updateAll(lat,lon,name);
      }).catch(()=>{});
  }
  el.btnGeo.addEventListener('click', ()=>{
    if(!navigator.geolocation) return;
    navigator.geolocation.getCurrentPosition(pos=>{
      const {latitude:lat, longitude:lon}=pos.coords;
      map.setView([lat,lon],11); setMarker(lat,lon,'You are here'); updateAll(lat,lon,'My location');
    });
  });
  el.btnPin.addEventListener('click', ()=>{
    const c=map.getCenter(); setMarker(c.lat,c.lng,'Pinned point'); updateAll(c.lat,c.lng,'Pinned point');
  });

  /* ===== Weather (Open-Meteo) ===== */
  el.units.addEventListener('change', ()=>{ const c=map.getCenter(); updateAll(c.lat,c.lng,'Updated units'); });

  function updateAll(lat,lon,label){
    el.badge.textContent=`${label||'Here'} • ${lat.toFixed(3)}, ${lon.toFixed(3)}`;
    updateForecast(lat,lon).then(()=>{
      if (el.useTomorrow?.checked) updateTomorrow(lat,lon);
    });
  }

  function updateForecast(lat,lon){
    const url=`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}`
      +`&current_weather=true`
      +`&hourly=temperature_2m,precipitation,cloudcover,windspeed_10m,weathercode,snowfall`
      +`&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,sunrise,sunset`
      +`&forecast_days=7&timezone=auto`;
    return fetch(url,{cache:'no-store'})
      .then(r=>r.json()).then(j=>{
        const metric=(el.units.value==='metric');
        const tNow=j?.current_weather?.temperature;
        const wArr=j?.hourly?.windspeed_10m||[], pArr=j?.hourly?.precipitation||[], cArr=j?.hourly?.cloudcover||[], sArr=j?.hourly?.snowfall||[];
        const sunrise=j?.daily?.sunrise?.[0], sunset=j?.daily?.sunset?.[0];
        const wMs=wArr[0], pMm=pArr[0], cl=cArr[0], snow=sArr[0];

        el.nowIcon.textContent=iconFor();
        el.temp.textContent=(tNow==null)?'Temp —':(metric?Math.round(tNow)+'°C':toF(tNow)+'°F');
        el.wind.dataset.source='openmeteo';
        el.wind.textContent=(wMs==null)?'Wind —':(metric?'Wind '+Math.round(wMs)+' m/s':'Wind '+msToMph(wMs)+' mph');
        el.precip.textContent=(pMm==null)?'Precip —':(metric?'Precip '+pMm+' mm':'Precip '+mmToIn(pMm)+' in');
        el.cloud.textContent=(cl==null)?'Cloud —':'Cloud '+cl+'%';
        el.sun.textContent=(sunrise&&sunset)?`Sunrise ${new Date(sunrise).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})} / Sunset ${new Date(sunset).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}`:'Sunrise — / Sunset —';
        el.risk.textContent=(snow>0?'❄ snow':'') + ((cl<=0 && pMm>0)?' • 🌧 rain':'') + (snow>0?' • 🧊 ice risk':'');
        el.updated.textContent='Updated '+new Date().toLocaleTimeString();

        // Hourly 24
        el.hourly.innerHTML='';
        const H=Math.min(24,(j?.hourly?.time||[]).length);
        for(let i=0;i<H;i++){
          const ti=j.hourly.time[i].slice(11,16);
          const tc=j.hourly.temperature_2m[i];
          const pp=j.hourly.precipitation[i];
          const div=document.createElement('div');
          div.className='hour';
          div.innerHTML=ti+'<div class="ico">☁</div>'
            +(metric?Math.round(tc)+'°C':toF(tc)+'°F')+'<br>'
            +(metric?pp+' mm':mmToIn(pp)+' in');
          el.hourly.appendChild(div);
        }
        // Daily 7
        el.daily.innerHTML='';
        const D=(j?.daily?.time||[]).length;
        for(let d=0; d<D; d++){
          const wd=new Date(j.daily.time[d]).toLocaleDateString(undefined,{weekday:'short'});
          const tmax=j.daily.temperature_2m_max[d], tmin=j.daily.temperature_2m_min[d];
          const pr=j.daily.precipitation_sum?.[d]??0;
          const row=document.createElement('div');
          row.className='day';
          row.innerHTML=wd+'<div class="ico">☁</div>'
            +(metric?Math.round(tmax)+'°C / '+Math.round(tmin)+'°C':toF(tmax)+'°F / '+toF(tmin)+'°F')+'<br>'
            +(metric?pr+' mm':mmToIn(pr)+' in');
          el.daily.appendChild(row);
        }
      });
  }

  /* ===== Use your Vercel proxy (Tomorrow.io hidden server-side) ===== */
  // If the endpoint exists and returns 200, reveal the switch
  fetch('/api/tomorrow?lat=53.35&lon=-6.26',{cache:'no-store'})
    .then(r=>{ if(r.ok && el.tomorrowWrap) el.tomorrowWrap.style.display='inline-block'; })
    .catch(()=>{ /* ignore */ });

  function updateTomorrow(lat,lon){
    // If the toggle is off, skip
    if (!el.useTomorrow || !el.useTomorrow.checked) return;
    const metric = (el.units.value==='metric');
    const u = metric ? 'metric' : 'imperial';
    fetch(`/api/tomorrow?lat=${lat}&lon=${lon}&units=${u}`, { cache:'no-store' })
      .then(r=>r.json())
      .then(j=>{
        const ws = j?.data?.values?.windSpeed; // Tomorrow returns m/s in metric
        if (ws==null) return;
        el.wind.dataset.source='tomorrow';
        el.wind.textContent = metric ? (`Wind ${Math.round(ws)} m/s (Tomorrow.io)`)
                                     : (`Wind ${Math.round(ws*2.23694)} mph (Tomorrow.io)`);
      })
      .catch(()=>{ /* silent */ });
  }
  el.useTomorrow?.addEventListener('change', ()=>{
    const c=map.getCenter(); updateAll(c.lat,c.lng,'Updated wind source');
  });

  /* ===== GPS (speed + HUD) ===== */
  function startGPS(){
    if(!navigator.geolocation){ el.gps.textContent='⏱ GPS not supported'; return; }
    if (gpsWatchId!==null) return;
    gpsWatchId = navigator.geolocation.watchPosition(pos=>{
      const {latitude:lat, longitude:lon, speed, heading}=pos.coords;
      lastSpeedMs = speed==null?0:speed;
      if (lastSpeedMs>maxSpeed) maxSpeed=lastSpeedMs;
      updateSpeedUI(heading);
      el.badge.textContent = `${lat.toFixed(3)}, ${lon.toFixed(3)} • ${fmtSpeed(lastSpeedMs)}`;
      if (!gotFix){ gotFix=true; map.setView([lat,lon],11); setMarker(lat,lon,'You are here'); updateAll(lat,lon,'My location'); }
    }, ()=>{ el.gps.textContent='⏱ GPS unavailable'; }, { enableHighAccuracy:true, maximumAge:4000, timeout:20000 });
  }
  el.toggleSpeed.addEventListener('click', ()=>{ speedUnit = (speedUnit==='kmh')?'mph':(speedUnit==='mph')?'knots':'kmh'; updateSpeedUI(NaN); });

  // Optional HUD controls (if you kept the HUD markup)
  el.speedoBtn?.addEventListener('click', ()=>{ el.speedHUD.style.display='flex'; });
  el.closeSpeed?.addEventListener('click', ()=>{ el.speedHUD.style.display='none'; });
  el.hudToggle?.addEventListener('click', ()=>{ el.toggleSpeed.click(); });

  /* ===== INIT ===== */
  loadRadar(); setInterval(loadRadar, 5*60*1000);
  startGPS();

  if (navigator.geolocation){
    navigator.geolocation.getCurrentPosition(
      p=>{ const {latitude:lat,longitude:lon}=p.coords; map.setView([lat,lon],11); updateAll(lat,lon,'My location'); },
      ()=>updateAll(53.35,-6.26,'Dublin area')
    );
  } else updateAll(53.35,-6.26,'Dublin area');
})();
</script>
