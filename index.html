         <button id="btnSeamark" class="btn">Seamarks</button>
        <span class="muted" style="padding:0 6px">Live</span>
        <button id="btnAircraft" class="btn">Aircraft</button>
        <button id="btnBoats" class="btn">Boats</button>
      </div>

      <div id="map"></div>

      <div class="muted" style="margin-top:8px">
        Basemaps:
        <span class="chip">OpenStreetMap</span>
        <span class="chip">Esri World Ocean</span>
        <span class="chip">Esri World Imagery (Satellite)</span>
        <span class="chip">OpenTopoMap</span>
        & overlays <span class="chip">OpenSeaMap Seamarks</span>,
        <span class="chip">Depth Contours</span>, <span class="chip">Rivers/Waterways</span>.
      </div>

      <details class="debug">
        <summary>Debug</summary>
        <div>API base: <span class="k" id="dbgBase">—</span></div>
        <div>OpenSky URL: <span class="k" id="dbgOpenSky">—</span> <span id="dbgOpenSkyState"></span></div>
        <div>AIS URL: <span class="k" id="dbgAis">—</span> <span id="dbgAisState"></span></div>
        <div>Planes: <span class="k" id="dbgPlaneCount">0</span> | Boats: <span class="k" id="dbgBoatCount">0</span></div>
        <pre id="raw" style="display:none"></pre>
      </details>
    </div>

    <div class="card" id="wxCard" style="margin-top:12px">
      <div class="toolbar" style="gap:8px">
        <button id="btnGeo" class="btn">Use my location</button>
        <input id="city" placeholder="Enter city (e.g., Dublin)" inputmode="search" autocomplete="off"/>
        <button id="btnCity" class="btn">Get weather</button>
        <span class="muted">API base: <b id="apiBaseTxt">—</b></span>
      </div>
      <div class="metric">
        <div class="muted">Temp:</div><b id="mTemp">—</b>
        <div class="muted">Wind:</div><b id="mWind">—</b>
        <div class="muted">Gust:</div><b id="mGust">—</b>
        <div class="muted">Direction:</div><b id="mDir">—</b>
        <div class="muted">Precip Prob:</div><b id="mPop">—</b>
        <div class="muted">Cloud Cover:</div><b id="mCloud">—</b>
      </div>
      <div id="err" class="error"></div>
    </div>
  </section>

  <!-- RIGHT -->
  <aside>
    <div class="card speedo">
      <div class="gauge" id="gauge">
        <div class="needle" id="needle" style="transform:translateX(-50%) rotate(180deg)"></div>
        <svg class="ticks" viewBox="0 0 100 50" preserveAspectRatio="none">
          <g stroke="#334a63" stroke-width="0.6">
            <line x1="5" y1="48" x2="5" y2="44"/>
            <line x1="15" y1="48" x2="15" y2="44"/>
            <line x1="25" y1="48" x2="25" y2="44"/>
            <line x1="35" y1="48" x2="35" y2="44"/>
            <line x1="45" y1="48" x2="45" y2="44"/>
            <line x1="55" y1="48" x2="55" y2="44"/>
            <line x1="65" y1="48" x2="65" y2="44"/>
            <line x1="75" y1="48" x2="75" y2="44"/>
            <line x1="85" y1="48" x2="85" y2="44"/>
            <line x1="95" y1="48" x2="95" y2="44"/>
          </g>
        </svg>
      </div>
      <div class="speed-read" id="spd">0.0</div>
      <div class="units">knots (kn)</div>
      <div class="muted" style="text-align:center;margin-top:6px">
        Uses GPS speed; falls back to distance over time if speed is missing.
      </div>
    </div>

    <div class="card">
      <div class="muted">Position</div>
      <div class="metric">
        <div class="muted">Lat:</div><b id="pLat">—</b>
        <div class="muted">Lon:</div><b id="pLon">—</b>
        <div class="muted">Acc:</div><b id="pAcc">—</b>
        <div class="muted">Bearing:</div><b id="pBrg">—</b>
      </div>
    </div>
  </aside>
</main>

<script>
/* ---------- HOSTING / API BASE ---------- */
const ON_VERCEL = location.hostname.endsWith('.vercel.app');
const ON_LOCAL = ['localhost','127.0.0.1'].includes(location.hostname);
const VERCEL_ORIGIN = 'https://legendary-umbrella-ashen.vercel.app';
const API_BASE = (ON_VERCEL || ON_LOCAL) ? '' : VERCEL_ORIGIN;
const $ = id => document.getElementById(id);
$('apiBaseTxt').textContent = API_BASE || '(same-origin)';
$('dbgBase').textContent = API_BASE || '(same-origin)';

const setStatus = t => $('status').textContent=t;
const showErr = msg => { const e=$('err'); e.style.display='block'; e.textContent=msg; }
const clearErr = () => { const e=$('err'); e.style.display='none'; e.textContent=''; }

/* ---------- CONFIG ---------- */
// DEMO true → show simulated planes/boats when feeds are empty/fail.
// Turn DEMO false once your real feeds are good.
const CONFIG = { DEMO: true };
// Thunderforest key (optional, if you want TF Outdoors basemap)
const TF_KEY = ""; // e.g. "abcd1234..."

let map, meMarker, meAccuracy, trackId=null, lastFix=null;
let osm, ocean, sat, topo, seamark;
let aircraftLayer = L.layerGroup();
let boatsLayer = L.layerGroup();

/* ---------- WEATHER HELPERS ---------- */
async function getTioKey(){
  const url = `${API_BASE}/api/tio-key`;
  const r = await fetch(url, {cache:'no-store'});
  if(!r.ok) throw new Error(`Failed to reach ${url} → ${r.status}`);
  const j = await r.json();
  if(!j?.key) throw new Error('tio-key endpoint returned no key.');
  return j.key;
}
async function tmrForecastByLatLon(lat,lon,key){
  const url = `https://api.tomorrow.io/v4/weather/forecast?location=${lat},${lon}&timesteps=1h&units=metric&apikey=${encodeURIComponent(key)}`;
  const r = await fetch(url); if(!r.ok) throw new Error(`Tomorrow.io ${r.status}`);
  return r.json();
}
async function tmrGeocodeCity(name,key){
  const url = `https://api.tomorrow.io/v4/locations?search=${encodeURIComponent(name)}&apikey=${encodeURIComponent(key)}`;
  const r = await fetch(url); if(!r.ok) throw new Error(`Geocode ${r.status}`);
  const j = await r.json(); const loc=j?.locations?.[0];
  if(!loc) throw new Error('City not found.');
  return { lat:loc.lat, lon:loc.lon, resolved:`${loc.name}, ${loc.countryCode}` };
}
function setWX(data){
  const point = data?.timelines?.hourly?.[0];
  if(!point) return;
  const v = point.values || {};
  $('mTemp').textContent = (v.temperature ?? '—') + ' °C';
  $('mWind').textContent = (v.windSpeed ?? '—') + ' m/s';
  $('mGust').textContent = (v.windGust ?? '—') + ' m/s';
  $('mDir').textContent = (v.windDirection ?? '—') + '°';
  $('mPop').textContent = (v.precipitationProbability ?? '—') + ' %';
  $('mCloud').textContent = (v.cloudCover ?? '—') + ' %';
  const dbgOpen = document.querySelector('details.debug')?.open;
  $('raw').style.display = dbgOpen ? 'block' : 'none';
  if (dbgOpen) $('raw').textContent = JSON.stringify(data,null,2);
}

/* ---------- MAP / LAYERS ---------- */
function initMap(){
  map = L.map('map',{center:[53.35,-6.26],zoom:10,minZoom:2});

  // Basemaps
  osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{
    maxZoom:19, attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  ocean = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}',{
    maxZoom:13, attribution: 'Tiles &copy; Esri Ocean'
  });

  sat = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',{
    maxZoom:19, attribution: 'Imagery &copy; Esri World Imagery'
  });

  topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',{
    maxZoom:17, attribution: 'Map data &copy; OpenTopoMap'
  });

  // Optional Thunderforest Outdoors
  const tfOutdoors = TF_KEY ? L.tileLayer(
    `https://tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey=${TF_KEY}`, {
      maxZoom:22, attribution: '&copy; Thunderforest, OpenStreetMap'
    }
  ) : null;

  // Overlays
  seamark = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',{
    maxZoom:18, opacity:0.95, attribution:'Seamarks &copy; OpenSeaMap'
  });

  const depth = L.tileLayer('https://tiles.openseamap.org/depth/{z}/{x}/{y}.png', {
    maxZoom:18, opacity:0.6, attribution:'Depth &copy; OpenSeaMap'
  });

  const waterways = L.tileLayer('https://tile.openstreetmap.fr/hydro/{z}/{x}/{y}.png', {
    maxZoom:18, opacity:0.7, attribution:'Hydro &copy; OSM France'
  });

  function readdLiveLayers(){
    if(meMarker) meMarker.addTo(map);
    if(meAccuracy) meAccuracy.addTo(map);
    if(map.hasLayer(aircraftLayer)) aircraftLayer.addTo(map);
    if(map.hasLayer(boatsLayer)) boatsLayer.addTo(map);
  }
  function switchBase(newBase){
    map.eachLayer(l=>{
      if(l!==seamark && l!==depth && l!==waterways && l!==aircraftLayer && l!==boatsLayer) {
        map.removeLayer(l);
      }
    });
    newBase.addTo(map);
    readdLiveLayers();
  }

  $('btnOSM').onclick   = ()=> switchBase(osm);
  $('btnOcean').onclick = ()=> switchBase(ocean);
  $('btnSat').onclick   = ()=> switchBase(sat);
  $('btnTopo').onclick  = ()=> switchBase(topo);
  $('btnSeamark').onclick = ()=> seamark.addTo(map);

  // Leaflet layer control
  const baseMaps = {"OSM":osm,"Esri Ocean":ocean,"Esri World Imagery (Satellite)":sat,"OpenTopoMap":topo};
  if (tfOutdoors) baseMaps["Thunderforest Outdoors"] = tfOutdoors;

  const overlays = {
    "OpenSeaMap Seamarks": seamark,
    "Depth Contours": depth,
    "Rivers / Waterways": waterways,
    "Aircraft": aircraftLayer,
    "Boats": boatsLayer
  };
  L.control.layers(baseMaps, overlays, {collapsed:true}).addTo(map);

  $('btnFull').onclick = ()=>{
    const el = $('map');
    if(!document.fullscreenElement){ el.requestFullscreen?.(); }
    else{ document.exitFullscreen?.(); }
  };
  $('btnCenter').onclick = ()=>{ if(lastFix){ map.setView([lastFix.coords.latitude,lastFix.coords.longitude], Math.max(map.getZoom(), 14)); } };

  setTimeout(()=> map.invalidateSize(), 0);
}

/* ---------- GEO / SPEEDO ---------- */
const R = 6371000;
const toRad = d=> d*Math.PI/180;
const haversine = (a,b)=>{
  const φ1=toRad(a.lat), φ2=toRad(b.lat), dφ=toRad(b.lat-a.lat), dλ=toRad(b.lon-a.lon);
  const s = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
  return 2*R*Math.asin(Math.sqrt(s));
};
const msToKn = ms => Number(ms*1.943844||0).toFixed(1);
function setNeedle(kn){
  const k = Math.max(0, Math.min(50, parseFloat(kn)||0));
  const deg = 180 - (k/50)*180;
  $('needle').style.transform = `translateX(-50%) rotate(${deg}deg)`;
  $('spd').textContent = k.toFixed(1);
}
function updateMeMarker(lat,lon,acc,brg){
  if(!meMarker){
    meMarker = L.marker([lat,lon]).addTo(map);
    meAccuracy = L.circle([lat,lon],{radius:acc||0,color:'#3b82f6',fillColor:'#3b82f6',fillOpacity:0.1}).addTo(map);
  }else{
    meMarker.setLatLng([lat,lon]);
    meAccuracy.setLatLng([lat,lon]).setRadius(acc||0);
  }
  $('pLat').textContent = lat.toFixed(5);
  $('pLon').textContent = lon.toFixed(5);
  $('pAcc').textContent = (acc? acc.toFixed(0)+' m' : '—');
  $('pBrg').textContent = (Number.isFinite(brg)? Math.round(brg)+'°' : '—');
}
function startTracking(){
  if(trackId) return;
  trackId = navigator.geolocation.watchPosition(pos=>{
    lastFix = pos;
    const {latitude:lat, longitude:lon, accuracy:acc, heading, speed} = pos.coords;
    updateMeMarker(lat,lon,acc,heading);
    let mps = Number.isFinite(speed) && speed!==null ? speed : null;
    if(!mps && window.__prevFix){
      const dt = (pos.timestamp - window.__prevFix.timestamp)/1000;
      if(dt>0){
        const d = haversine({lat:window.__prevFix.coords.latitude,lon:window.__prevFix.coords.longitude},{lat,lon});
        mps = d/dt;
      }
    }
    window.__prevFix = pos;
    setNeedle(msToKn(mps||0));
  }, err=> showErr('GPS error: '+err.message),
  { enableHighAccuracy:true, maximumAge:0, timeout:15000 });
  $('btnTrack').textContent = 'Tracking…';
}
function stopTracking(){ if(trackId){ navigator.geolocation.clearWatch(trackId); trackId=null; $('btnTrack').textContent='Start tracking'; } }
$('btnTrack').onclick = ()=> trackId ? stopTracking() : startTracking();

/* ---------- LIVE LAYERS: AIRCRAFT & BOATS ---------- */
let aircraftTimer = null, boatsTimer = null;

function planeIcon(){ return L.icon({ iconUrl:'https://cdn-icons-png.flaticon.com/512/3448/3448339.png', iconSize:[20,20], iconAnchor:[10,10] }); }
function boatIcon(){  return L.icon({ iconUrl:'https://cdn-icons-png.flaticon.com/512/77/77521.png',    iconSize:[20,20], iconAnchor:[10,10] }); }

// DEMO helpers
function randomAround([lat,lon], km=20){
  const r = km/111; return [lat + (Math.random()-0.5)*r, lon + (Math.random()-0.5)*r];
}
function demoPlanes(count=6){
  const c = map.getCenter(); const out=[];
  for(let i=0;i<count;i++){ const [lat,lon]=randomAround([c.lat,c.lng],60);
    out.push({lat,lon,callsign:`EI-D${String(i).padStart(2,'0')}`, cog:Math.floor(Math.random()*360), sog:(180+Math.random()*120)/1.943844});
  } return out;
}
function demoBoats(count=8){
  const c = map.getCenter(); const out=[];
  for(let i=0;i<count;i++){ const [lat,lon]=randomAround([c.lat,c.lng],40);
    out.push({lat,lon,name:`IE Boat ${i+1}`, cog:Math.floor(Math.random()*360), sog:(5+Math.random()*15).toFixed(1)});
  } return out;
}

// OpenSky proxy
async function fetchAircraftBBox(){
  const b = map.getBounds();
  const url = `${API_BASE}/api/opensky?n=${b.getNorth()}&s=${b.getSouth()}&e=${b.getEast()}&w=${b.getWest()}`;
  $('dbgOpenSky').textContent = url;
  const r = await fetch(url, { cache:'no-store' });
  $('dbgOpenSkyState').innerHTML = r.ok ? '<span class="ok">✓</span>' : `<span class="bad">✗ ${r.status}</span>`;
  if(!r.ok) throw new Error('opensky '+r.status);
  return r.json();
}
async function refreshAircraft(){
  try{
    const data = await fetchAircraftBBox();
    aircraftLayer.clearLayers();
    const states = data.states || [];
